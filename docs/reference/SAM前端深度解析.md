# SAM å‰ç«¯å›¾åƒåˆ†å‰²æ·±åº¦è§£æ

> ä»ä½¿ç”¨åˆ°åŸç†ï¼Œä»æ•°æ®åˆ°å®ç°çš„å®Œæ•´æŠ€æœ¯ä¹‹æ—…  
> ä½œè€…ï¼šèµ„æ·±å‰ç«¯ä¸“å®¶ & å¤§æ¨¡å‹æŠ€æœ¯è®²å¸ˆ

---

## è¯¾ç¨‹å¯¼èˆª

**ç¬¬ä¸€éƒ¨åˆ†ï¼šå¿«é€Ÿä¸Šæ‰‹**
- [ç¬¬ä¸€ç« ï¼š5åˆ†é’Ÿå¿«é€Ÿä½“éªŒ](#ç¬¬ä¸€ç« 5åˆ†é’Ÿå¿«é€Ÿä½“éªŒ)

**ç¬¬äºŒéƒ¨åˆ†:æ•°æ®æµè½¬è¯¦è§£**
- [ç¬¬äºŒç« ï¼šè‡ªåŠ¨åˆ†å‰²çš„æ•°æ®æ—…ç¨‹](#ç¬¬äºŒç« è‡ªåŠ¨åˆ†å‰²çš„æ•°æ®æ—…ç¨‹)
- [ç¬¬ä¸‰ç« ï¼šäº¤äº’å¼åˆ†å‰²çš„æ•°æ®æ—…ç¨‹](#ç¬¬ä¸‰ç« äº¤äº’å¼åˆ†å‰²çš„æ•°æ®æ—…ç¨‹)

**ç¬¬ä¸‰éƒ¨åˆ†ï¼šå®ç°å‰–æ**
- [ç¬¬å››ç« ï¼šRLEæ•°æ®çš„è§£ç å®ç°](#ç¬¬å››ç« rleæ•°æ®çš„è§£ç å®ç°)
- [ç¬¬äº”ç« ï¼šé¢œè‰²IDæ‹¾å–ç³»ç»Ÿçš„å®ç°](#ç¬¬äº”ç« é¢œè‰²idæ‹¾å–ç³»ç»Ÿçš„å®ç°)
- [ç¬¬å…­ç« ï¼šå›¾å±‚åˆæˆçš„å®ç°](#ç¬¬å…­ç« å›¾å±‚åˆæˆçš„å®ç°)
- [ç¬¬ä¸ƒç« ï¼šONNXæ¨ç†çš„å®ç°](#ç¬¬ä¸ƒç« onnxæ¨ç†çš„å®ç°)

**ç¬¬å››éƒ¨åˆ†ï¼šåŸç†æ·±åº¦å‰–æ**
- [ç¬¬å…«ç« ï¼šSAMæ¨¡å‹çš„å·¥ä½œåŸç†](#ç¬¬å…«ç« samæ¨¡å‹çš„å·¥ä½œåŸç†)
- [ç¬¬ä¹ç« ï¼šCanvaså›¾åƒå¤„ç†åŸç†](#ç¬¬ä¹ç« canvaså›¾åƒå¤„ç†åŸç†)

**ç¬¬äº”éƒ¨åˆ†ï¼šå®æˆ˜è¿›é˜¶**
- [ç¬¬åç« ï¼šæ€§èƒ½ä¼˜åŒ–å®æˆ˜](#ç¬¬åç« æ€§èƒ½ä¼˜åŒ–å®æˆ˜)
- [ç¬¬åä¸€ç« ï¼šå¸¸è§é—®é¢˜è§£å†³](#ç¬¬åä¸€ç« å¸¸è§é—®é¢˜è§£å†³)

---

# ç¬¬ä¸€éƒ¨åˆ†ï¼šå¿«é€Ÿä¸Šæ‰‹

## ç¬¬ä¸€ç« ï¼š5åˆ†é’Ÿå¿«é€Ÿä½“éªŒ

### 1.1 æˆ‘ä»¬è¦åšä»€ä¹ˆï¼Ÿ

æƒ³è±¡ä¸€ä¸‹ï¼Œä½ æ­£åœ¨å¼€å‘ä¸€ä¸ªå›¾ç‰‡ç¼–è¾‘å™¨ï¼Œç”¨æˆ·ä¸Šä¼ äº†ä¸€å¼ ç…§ç‰‡ï¼Œé‡Œé¢æœ‰ä¸€åªçŒ«ã€‚ç”¨æˆ·å¸Œæœ›ï¼š
1. **ç‚¹å‡»çŒ«**ï¼Œè‡ªåŠ¨é€‰ä¸­æ•´åªçŒ«
2. **å¯¼å‡ºæŠ å›¾**ï¼Œè·å¾—é€æ˜èƒŒæ™¯çš„çŒ«å’ªå›¾ç‰‡

è¿™å°±æ˜¯ SAM åŒ…è¦å¸®ä½ å®ç°çš„åŠŸèƒ½ã€‚è®©æˆ‘ä»¬ä»æœ€ç®€å•çš„ä¾‹å­å¼€å§‹ã€‚

### 1.2 æœ€å°å¯è¿è¡Œç¤ºä¾‹

```typescript
import { SamFactory } from '@lego/sam';
import axios from 'axios';

// æ­¥éª¤1ï¼šåˆå§‹åŒ–å·¥å‚
const factory = SamFactory.getInstance({
  axiosInstance: axios.create({ baseURL: 'https://your-api.com' }),
  upload: async (blob) => {
    // ä½ çš„æ–‡ä»¶ä¸Šä¼ é€»è¾‘
    return 'https://cdn.com/uploaded-file.png';
  },
  loadImage: (url) => {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.onload = () => resolve(img);
      img.onerror = reject;
      img.src = url;
    });
  }
});

// æ­¥éª¤2ï¼šåˆ›å»ºæ¨¡å‹
const model = await factory.createAutoMaskModel('https://example.com/cat.jpg');

// æ­¥éª¤3ï¼šç”¨æˆ·ç‚¹å‡»çŒ«çš„ä½ç½®ï¼ˆå‡è®¾åæ ‡æ˜¯300, 200ï¼‰
const result = model.toggleLayerMode(300, 200);

// æ­¥éª¤4ï¼šå¯¼å‡ºæŠ å›¾
if (result) {
  const cutoutImage = result.getImage();
  // cutoutImage å°±æ˜¯æŠ å‡ºæ¥çš„çŒ«å’ªå›¾ç‰‡ï¼ˆCanvaså¯¹è±¡ï¼‰
}
```

### 1.3 è¿™å››æ­¥èƒŒåå‘ç”Ÿäº†ä»€ä¹ˆï¼Ÿ

ç°åœ¨ä½ å·²ç»å®Œæˆäº†åŸºæœ¬çš„æŠ å›¾ï¼Œä½†ä½ å¯èƒ½æœ‰å¾ˆå¤šç–‘é—®ï¼š
- **æ­¥éª¤2** è°ƒç”¨ `createAutoMaskModel` æ—¶ï¼Œå†…éƒ¨è¯·æ±‚äº†ä»€ä¹ˆæ•°æ®ï¼Ÿ
- **æ­¥éª¤3** ç‚¹å‡»åï¼Œå¦‚ä½•çŸ¥é“ç”¨æˆ·ç‚¹çš„æ˜¯å“ªä¸€å±‚ï¼Ÿ
- **æ­¥éª¤4** `getImage()` å¦‚ä½•ç”ŸæˆæŠ å›¾çš„ï¼Ÿ

åˆ«æ€¥ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬ä¼šä¸€å±‚å±‚æ­å¼€è¿™äº›è°œå›¢ã€‚

---

# ç¬¬äºŒéƒ¨åˆ†ï¼šæ•°æ®æµè½¬è¯¦è§£

## ç¬¬äºŒç« ï¼šè‡ªåŠ¨åˆ†å‰²çš„æ•°æ®æ—…ç¨‹

### 2.1 æ•´ä½“æ•°æ®æµæ¦‚è§ˆ

è®©æˆ‘ç”¨ä¸€ä¸ªå®Œæ•´çš„æ•°æ®æµå›¾æ¥å±•ç¤ºæ•´ä¸ªè¿‡ç¨‹ï¼š

```
ç”¨æˆ·å›¾ç‰‡URL
    â†“
ã€åç«¯APIã€‘è¿”å› RLE æ•°æ®
    â†“
ã€å‰ç«¯è§£ç ã€‘RLE â†’ åƒç´ æ•°æ®
    â†“
ã€ç»˜åˆ¶Canvasã€‘åƒç´  â†’ å¤šå±‚Canvas
    â†“
ã€é¢œè‰²æ ‡è®°ã€‘æ¯å±‚åˆ†é…å”¯ä¸€é¢œè‰²ID
    â†“
ã€ç”¨æˆ·ç‚¹å‡»ã€‘
    â†“
ã€é¢œè‰²åŒ¹é…ã€‘æ‰¾åˆ°å¯¹åº”çš„å±‚
    â†“
ã€å›¾å±‚åˆæˆã€‘å¤šå±‚æ··åˆ
    â†“
ã€å¯¼å‡ºç»“æœã€‘Mask Canvas æˆ–æŠ å›¾ Canvas
```

ç°åœ¨ï¼Œè®©æˆ‘ä»¬è¯¦ç»†æ‹†è§£æ¯ä¸€æ­¥ã€‚

### 2.2 ç¬¬ä¸€ç«™ï¼šåç«¯è¿”å›çš„RLEæ•°æ®

#### æ•°æ®ç»“æ„

å½“ä½ è°ƒç”¨ `createAutoMaskModel(imageUrl)` æ—¶ï¼Œå†…éƒ¨ä¼šå‘åç«¯å‘é€è¯·æ±‚ï¼š

```typescript
POST /gdesign/tool/ai/auto-masks
{
  url: "https://example.com/cat.jpg",
  mask_generator_config: {
    output_mode: "uncompressed_rle"
  }
}
```

åç«¯ä¼šè¿”å›ä¸€ä¸ª**æ•°ç»„**ï¼Œæ¯ä¸ªå…ƒç´ ä»£è¡¨ä¸€å±‚åˆ†å‰²ç»“æœï¼š

```json
[
  {
    "area": 15234,
    "segmentation": {
      "counts": [0, 8, 15, 4, 23, 7, ...],
      "size": [1024, 768]
    }
  },
  {
    "area": 8932,
    "segmentation": {
      "counts": [120, 5, 89, 12, ...],
      "size": [1024, 768]
    }
  },
  ...
]
```

#### æ•°æ®å«ä¹‰è§£è¯»

è®©æˆ‘è¯¦ç»†è§£é‡Šè¿™ä¸ªæ•°æ®ç»“æ„ï¼š

**1. `area` å­—æ®µ**
- **å«ä¹‰**ï¼šè¿™ä¸€å±‚åŒ…å«å¤šå°‘ä¸ªåƒç´ 
- **ä½œç”¨**ï¼šç”¨äºæ’åºï¼ˆé¢ç§¯å¤§çš„åœ¨å‰ï¼‰å’Œåˆ¤æ–­å±‚çš„åŒ…å«å…³ç³»
- **ä¾‹å­**ï¼š15234 è¡¨ç¤ºè¿™ä¸€å±‚æœ‰ 15234 ä¸ªç™½è‰²åƒç´ 

**2. `segmentation.size` å­—æ®µ**
- **å«ä¹‰**ï¼š`[é«˜åº¦, å®½åº¦]`ï¼Œæ³¨æ„é¡ºåºï¼
- **ä½œç”¨**ï¼šå‘Šè¯‰æˆ‘ä»¬è¿™ä¸ªmaskçš„å°ºå¯¸
- **ä¾‹å­**ï¼š`[1024, 768]` è¡¨ç¤ºé«˜1024åƒç´ ï¼Œå®½768åƒç´ 

**3. `segmentation.counts` å­—æ®µï¼ˆæ ¸å¿ƒï¼‰**
- **å«ä¹‰**ï¼šRLEç¼–ç çš„æ¸¸ç¨‹æ•°ç»„
- **ä½œç”¨**ï¼šå‹ç¼©å­˜å‚¨maskçš„åƒç´ ä¿¡æ¯
- **ä¾‹å­**ï¼š`[0, 8, 15, 4, 23, 7]` çš„æ„æ€æ˜¯ï¼š
  - ä»ç¬¬0ä¸ªä½ç½®å¼€å§‹
  - è·³è¿‡0ä¸ªåƒç´ ï¼ˆ0ä¸ªé»‘è‰²ï¼‰
  - æ¥ç€8ä¸ªç™½è‰²åƒç´ 
  - å†è·³è¿‡15ä¸ªé»‘è‰²åƒç´ 
  - å†4ä¸ªç™½è‰²åƒç´ 
  - ...ä»¥æ­¤ç±»æ¨

#### ä¸ºä»€ä¹ˆç”¨RLEç¼–ç ï¼Ÿ

è®©æˆ‘ç”¨ä¸€ä¸ªç›´è§‚çš„ä¾‹å­è¯´æ˜ï¼š

**åŸå§‹æ–¹å¼**ï¼ˆ1024Ã—768 = 786,432 ä¸ªåƒç´ ï¼‰ï¼š
```
[0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,...]  // éœ€è¦å­˜å‚¨786,432ä¸ªæ•°å­—
```

**RLEæ–¹å¼**ï¼ˆå‡è®¾åªæœ‰50æ®µè¿ç»­åŒºåŸŸï¼‰ï¼š
```
[5, 6, 5, ...]  // åªéœ€è¦å­˜å‚¨çº¦100ä¸ªæ•°å­—
```

**å‹ç¼©æ¯”**ï¼š786,432 / 100 = **7864å€**ï¼

### 2.3 ç¬¬äºŒç«™ï¼šRLEè§£ç æˆåƒç´ æ•°æ®

#### è§£ç çš„ç›®æ ‡

æˆ‘ä»¬éœ€è¦æŠŠ `counts: [0, 8, 15, 4, ...]` è¿˜åŸæˆä¸€ä¸ªå®Œæ•´çš„åƒç´ æ•°ç»„ï¼Œå…¶ä¸­ï¼š
- å€¼ä¸º `0` çš„ä½ç½®è¡¨ç¤ºèƒŒæ™¯ï¼ˆé»‘è‰²ï¼‰
- å€¼ä¸º `1` çš„ä½ç½®è¡¨ç¤ºå‰æ™¯ï¼ˆç™½è‰²ï¼‰

#### è§£ç çš„æ ¸å¿ƒé€»è¾‘

```typescript
// è¾“å…¥ï¼šRLEçš„countsæ•°ç»„
const counts = [0, 8, 15, 4, 23, 7];
const width = 768;
const height = 1024;

// è¾“å‡ºï¼šRGBAåƒç´ æ•°ç»„ï¼ˆæ¯ä¸ªåƒç´ 4ä¸ªå€¼ï¼šR, G, B, Aï¼‰
const pixelData = new Uint8ClampedArray(width * height * 4);

let currentPosition = 0;  // å½“å‰å†™å…¥çš„åƒç´ ä½ç½®

for (let i = 0; i < counts.length; i += 2) {
  const zeroCount = counts[i];      // é»‘è‰²åƒç´ æ•°é‡
  const oneCount = counts[i + 1];   // ç™½è‰²åƒç´ æ•°é‡
  
  // è·³è¿‡é»‘è‰²åƒç´ ï¼ˆä¿æŒä¸º0ï¼Œä¸ç”¨å†™å…¥ï¼‰
  currentPosition += zeroCount;
  
  // å¡«å……ç™½è‰²åƒç´ 
  for (let j = 0; j < oneCount; j++) {
    const index = currentPosition * 4;
    pixelData[index] = 255;      // R
    pixelData[index + 1] = 255;  // G
    pixelData[index + 2] = 255;  // B
    pixelData[index + 3] = 255;  // A
    currentPosition++;
  }
}
```

#### å…³é”®ç‚¹ï¼šåæ ‡è½¬æ¢

è¿™é‡Œæœ‰ä¸ª**éå¸¸é‡è¦çš„ç»†èŠ‚**ï¼šSAMè¿”å›çš„RLEæ•°æ®æ˜¯**æ—‹è½¬90åº¦**çš„ï¼

ä¸ºä»€ä¹ˆï¼Ÿå› ä¸ºSAMå†…éƒ¨çš„å­˜å‚¨é¡ºåºæ˜¯æŒ‰åˆ—ä¼˜å…ˆï¼ˆcolumn-majorï¼‰ï¼Œè€ŒCanvasæ˜¯æŒ‰è¡Œä¼˜å…ˆï¼ˆrow-majorï¼‰ã€‚

æ‰€ä»¥è§£ç åï¼Œæˆ‘ä»¬éœ€è¦ï¼š
```typescript
// 1. å…ˆè§£ç åˆ°ä¸´æ—¶Canvasï¼ˆå®½é«˜äº’æ¢ï¼‰
tempCanvas.width = height;   // æ³¨æ„ï¼šå®½åº¦ç”¨é«˜åº¦å€¼
tempCanvas.height = width;   // é«˜åº¦ç”¨å®½åº¦å€¼

// 2. ç»˜åˆ¶è§£ç åçš„åƒç´ 
tempCtx.putImageData(imageData, 0, 0);

// 3. æ—‹è½¬å›æ­£å¸¸æ–¹å‘
finalCanvas.width = width;
finalCanvas.height = height;
const ctx = finalCanvas.getContext('2d');
ctx.scale(1, -1);
ctx.rotate(-90 * Math.PI / 180);
ctx.drawImage(tempCanvas, 0, 0);
```

### 2.4 ç¬¬ä¸‰ç«™ï¼šä¸ºæ¯ä¸€å±‚åˆ†é…é¢œè‰²ID

#### ä¸ºä»€ä¹ˆéœ€è¦é¢œè‰²IDï¼Ÿ

ç°åœ¨æˆ‘ä»¬æœ‰äº†å¤šä¸ªå±‚ï¼ˆæ¯”å¦‚50å±‚ï¼‰ï¼Œæ¯å±‚éƒ½æ˜¯ä¸€ä¸ªCanvasã€‚å½“ç”¨æˆ·ç‚¹å‡»æ—¶ï¼Œæˆ‘ä»¬éœ€è¦å¿«é€ŸçŸ¥é“ç‚¹å‡»çš„æ˜¯å“ªä¸€å±‚ã€‚

æœ€ç›´è§‚çš„æ–¹æ³•æ˜¯éå†æ‰€æœ‰å±‚ï¼Œæ£€æŸ¥ç‚¹å‡»ä½ç½®çš„åƒç´ ï¼š
```typescript
// âŒ ä½æ•ˆæ–¹æ³•
for (let layer of layers) {
  const pixel = layer.canvas.getImageData(x, y, 1, 1);
  if (pixel.data[3] > 0) {
    return layer;  // æ‰¾åˆ°äº†
  }
}
```

**é—®é¢˜**ï¼š50å±‚ Ã— æ¯å±‚è¯»å–ImageData = éå¸¸æ…¢ï¼

#### é¢œè‰²IDçš„å·§å¦™æ–¹æ¡ˆ

æˆ‘ä»¬åˆ›å»ºä¸€ä¸ª**éšè—çš„pickCanvas**ï¼Œåœ¨è¿™ä¸ªCanvasä¸Šï¼š
- ç¬¬1å±‚ç”¨é¢œè‰² `rgb(0, 0, 1)` ç»˜åˆ¶
- ç¬¬2å±‚ç”¨é¢œè‰² `rgb(0, 0, 2)` ç»˜åˆ¶
- ç¬¬3å±‚ç”¨é¢œè‰² `rgb(0, 0, 3)` ç»˜åˆ¶
- ...

å½“ç”¨æˆ·ç‚¹å‡»æ—¶ï¼Œåªéœ€è¦ï¼š
```typescript
// âœ… é«˜æ•ˆæ–¹æ³•ï¼ˆO(1)æ—¶é—´å¤æ‚åº¦ï¼‰
const pixel = pickCanvas.getImageData(x, y, 1, 1);
const colorId = pixel.data[2];  // è¯»å–Bé€šé“çš„å€¼
return layerMap.get(colorId);   // ç›´æ¥å®šä½åˆ°å¯¹åº”å±‚
```

#### é¢œè‰²IDçš„ç”Ÿæˆ

```typescript
class ColorIdService {
  private n = 0;
  
  generateID() {
    this.n += 1;
    
    // å°†æ•°å­—ç¼–ç ä¸ºRGB
    const r = (this.n >>> 16) & 0xFF;  // é«˜8ä½
    const g = (this.n >>> 8) & 0xFF;   // ä¸­8ä½
    const b = this.n & 0xFF;           // ä½8ä½
    
    return {
      id: this.n.toString(),
      color: [r, g, b, 255]
    };
  }
}
```

**ä¸¾ä¾‹**ï¼š
- ID=1 â†’ `rgb(0, 0, 1)`
- ID=256 â†’ `rgb(0, 1, 0)`
- ID=65536 â†’ `rgb(1, 0, 0)`

è¿™æ ·å¯ä»¥æ”¯æŒ **16,777,216** å±‚ï¼ˆ2^24ï¼‰ã€‚

### 2.5 ç¬¬å››ç«™ï¼šç”¨æˆ·ç‚¹å‡»åçš„å±‚åŒ¹é…

#### å®Œæ•´çš„ç‚¹å‡»å¤„ç†æµç¨‹

å½“ç”¨æˆ·ç‚¹å‡»åæ ‡ `(300, 200)` æ—¶ï¼š

```typescript
pickLayer(x, y) {
  // 1. åæ ‡è½¬æ¢ï¼ˆå±å¹•åæ ‡ â†’ Canvasåæ ‡ï¼‰
  const scale = this.pickCanvas.width / this.image.naturalWidth;
  const canvasX = x * scale;
  const canvasY = y * scale;
  
  // 2. è¯»å–pickCanvasä¸Šçš„é¢œè‰²
  const ctx = this.pickCanvas.getContext('2d');
  const pixel = ctx.getImageData(canvasX, canvasY, 1, 1);
  const clickedColor = [
    pixel.data[0],
    pixel.data[1],
    pixel.data[2],
    pixel.data[3]
  ];
  
  // 3. æ‰¾åˆ°æœ€æ¥è¿‘çš„é¢œè‰²ID
  let minDistance = Infinity;
  let matchedLayer = null;
  
  for (let layer of this.layers) {
    const distance = this.colorDistance(layer.color, clickedColor);
    if (distance < 3 && distance < minDistance) {
      minDistance = distance;
      matchedLayer = layer;
    }
  }
  
  return matchedLayer;
}
```

#### ä¸ºä»€ä¹ˆéœ€è¦é¢œè‰²è·ç¦»ï¼Ÿ

ç†è®ºä¸Šé¢œè‰²åº”è¯¥å®Œå…¨åŒ¹é…ï¼Œä½†å®é™…ä¸­å¯èƒ½å› ä¸ºï¼š
- Canvasçš„æŠ—é”¯é½¿
- æµè§ˆå™¨çš„é¢œè‰²ç©ºé—´è½¬æ¢
- æµ®ç‚¹æ•°ç²¾åº¦é—®é¢˜

å¯¼è‡´é¢œè‰²æœ‰ç»†å¾®å·®å¼‚ã€‚æ‰€ä»¥æˆ‘ä»¬ç”¨**æ¬§å¼è·ç¦»**æ¥åŒ¹é…ï¼š

```typescript
colorDistance(color1, color2) {
  const dr = color1[0] - color2[0];
  const dg = color1[1] - color2[1];
  const db = color1[2] - color2[2];
  return Math.sqrt(dr*dr + dg*dg + db*db);
}
```

é˜ˆå€¼è®¾ä¸º3ï¼Œæ„å‘³ç€RGBæ¯ä¸ªé€šé“æœ€å¤šå·®1ä¸ªå•ä½ã€‚

### 2.6 ç¬¬äº”ç«™ï¼šå›¾å±‚åˆæˆ

#### ä¸‰ç§æ¨¡å¼

æ‰¾åˆ°ç”¨æˆ·ç‚¹å‡»çš„å±‚åï¼Œæˆ‘ä»¬éœ€è¦å†³å®šå®ƒçš„**åˆæˆæ¨¡å¼**ï¼š

| æ¨¡å¼ | å€¼ | å«ä¹‰ | Canvasæ“ä½œ |
|-----|---|------|-----------|
| æœªé€‰ä¸­ | `null` | ä¸å‚ä¸åˆæˆ | ä¸ç»˜åˆ¶ |
| æ­£é€‰ | `'source-over'` | æ·»åŠ åˆ°é€‰åŒº | å åŠ ç»˜åˆ¶ |
| è´Ÿé€‰ | `'destination-out'` | ä»é€‰åŒºæ‰£é™¤ | æ“¦é™¤ç»˜åˆ¶ |

#### æ¨¡å¼åˆ‡æ¢é€»è¾‘

```typescript
toggleLayerMode(x, y) {
  const clickedLayer = this.pickLayer(x, y);
  if (!clickedLayer) return null;
  
  // æ£€æŸ¥ç‚¹å‡»ä½ç½®æ˜¯å¦æœ‰å…¶ä»–å·²é€‰ä¸­çš„å±‚
  const overlappingLayers = this.findOverlappingLayers(x, y);
  
  if (overlappingLayers.length === 0) {
    // æƒ…å†µ1ï¼šç‹¬ç«‹åŒºåŸŸï¼Œç®€å•åˆ‡æ¢
    if (clickedLayer.mode === null) {
      clickedLayer.mode = 'source-over';  // é€‰ä¸­
    } else {
      clickedLayer.mode = null;  // å–æ¶ˆé€‰ä¸­
    }
  } else {
    // æƒ…å†µ2ï¼šåœ¨å·²é€‰åŒºåŸŸå†…éƒ¨ï¼Œåˆ‡æ¢ä¸ºè´Ÿé€‰
    const largerSelectedLayer = overlappingLayers.find(
      l => l.area > clickedLayer.area && l.mode === 'source-over'
    );
    
    if (largerSelectedLayer) {
      if (clickedLayer.mode === null) {
        clickedLayer.mode = 'destination-out';  // æ‰£é™¤
      } else if (clickedLayer.mode === 'destination-out') {
        clickedLayer.mode = null;  // å–æ¶ˆæ‰£é™¤
      }
    }
  }
  
  return this.composeLayers();
}
```

#### æœ€ç»ˆåˆæˆ

```typescript
composeLayers() {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  
  // æŒ‰é¡ºåºç»˜åˆ¶æ‰€æœ‰é€‰ä¸­çš„å±‚
  for (let layer of this.layers) {
    if (layer.mode !== null) {
      ctx.globalCompositeOperation = layer.mode;
      ctx.drawImage(layer.maskCanvas, 0, 0);
    }
  }
  
  return new AutoMaskResult(this.image, canvas);
}
```

### 2.7 ç¬¬å…­ç«™ï¼šå¯¼å‡ºç»“æœ

#### ä¸¤ç§å¯¼å‡ºæ–¹å¼

**æ–¹å¼1ï¼šå¯¼å‡ºMask**
```typescript
getMask() {
  // è¿”å›é»‘ç™½maskï¼ˆç™½è‰²=é€‰ä¸­åŒºåŸŸï¼Œé»‘è‰²=èƒŒæ™¯ï¼‰
  return this.maskCanvas;
}
```

**æ–¹å¼2ï¼šå¯¼å‡ºæŠ å›¾**
```typescript
getImage() {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  
  // 1. å…ˆç»˜åˆ¶mask
  ctx.drawImage(this.maskCanvas, 0, 0);
  
  // 2. ä½¿ç”¨maskä½œä¸ºé®ç½©ï¼Œç»˜åˆ¶åŸå›¾
  ctx.globalCompositeOperation = 'source-in';
  ctx.drawImage(this.image, 0, 0);
  
  // ç»“æœï¼šåªæœ‰maskç™½è‰²åŒºåŸŸä¿ç•™åŸå›¾ï¼Œå…¶ä½™é€æ˜
  return canvas;
}
```

#### Canvasæ··åˆæ¨¡å¼çš„é­”æ³•

`globalCompositeOperation = 'source-in'` çš„å«ä¹‰ï¼š
- åªä¿ç•™**æ–°ç»˜åˆ¶å†…å®¹**ï¼ˆsourceï¼‰ä¸**å·²æœ‰å†…å®¹**ï¼ˆdestinationï¼‰**é‡å **çš„éƒ¨åˆ†

```
å·²æœ‰å†…å®¹ï¼ˆmaskï¼‰ï¼š  æ–°ç»˜åˆ¶å†…å®¹ï¼ˆåŸå›¾ï¼‰ï¼š  ç»“æœï¼š
â–¡â–¡â–¡â–¡â–¡â–¡â–¡â–¡          ğŸ±ğŸ±ğŸ±ğŸ±            â¬œâ¬œâ¬œâ¬œ
â–¡â– â– â– â– â–¡â–¡â–¡          ğŸ±ğŸ±ğŸ±ğŸ±            â¬œğŸ±ğŸ±ğŸ±
â–¡â– â– â– â– â–¡â–¡â–¡          ğŸ±ğŸ±ğŸ±ğŸ±            â¬œğŸ±ğŸ±ğŸ±
â–¡â–¡â–¡â–¡â–¡â–¡â–¡â–¡          ğŸ±ğŸ±ğŸ±ğŸ±            â¬œâ¬œâ¬œâ¬œ
(â– =ç™½è‰²mask)      (åŸå›¾)              (æŠ å›¾ç»“æœ)
```

---

## ç¬¬ä¸‰ç« ï¼šäº¤äº’å¼åˆ†å‰²çš„æ•°æ®æ—…ç¨‹

### 3.1 ä¸è‡ªåŠ¨åˆ†å‰²çš„åŒºåˆ«

**è‡ªåŠ¨åˆ†å‰²**ï¼šåç«¯é¢„å…ˆè®¡ç®—å¥½æ‰€æœ‰å¯èƒ½çš„åˆ†å‰²å±‚ï¼Œå‰ç«¯åªéœ€é€‰æ‹©å’Œç»„åˆã€‚

**äº¤äº’å¼åˆ†å‰²**ï¼šæ ¹æ®ç”¨æˆ·çš„ç‚¹å‡»ç‚¹ï¼Œ**å®æ—¶æ¨ç†**ç”Ÿæˆmaskã€‚

æ•°æ®æµå¯¹æ¯”ï¼š

```
è‡ªåŠ¨åˆ†å‰²ï¼š
å›¾ç‰‡URL â†’ åç«¯è®¡ç®— â†’ RLEæ•°æ® â†’ å‰ç«¯è§£ç  â†’ å¤šå±‚Canvas

äº¤äº’å¼åˆ†å‰²ï¼š
å›¾ç‰‡URL â†’ åç«¯ç”ŸæˆEmbedding â†’ å‰ç«¯ONNXæ¨ç† â†’ å•ä¸ªMask
```

### 3.2 ç¬¬ä¸€ç«™ï¼šEmbeddingæ•°æ®

#### ä»€ä¹ˆæ˜¯Embeddingï¼Ÿ

Embeddingï¼ˆåµŒå…¥ï¼‰æ˜¯å›¾åƒçš„**é«˜ç»´ç‰¹å¾è¡¨ç¤º**ï¼ŒåŒ…å«äº†å›¾åƒçš„æ‰€æœ‰è¯­ä¹‰ä¿¡æ¯ã€‚

```typescript
POST /gdesign/tool/ai/embedding
{
  url: "https://example.com/cat.jpg"
}

// å“åº”
{
  embedding_file_url: "https://cdn.com/embeddings/xxx.emb"
}
```

#### Embeddingçš„æ•°æ®æ ¼å¼

ä¸‹è½½ `xxx.emb` æ–‡ä»¶åï¼Œä½ ä¼šå¾—åˆ°ä¸€ä¸ª**Base64ç¼–ç çš„å­—ç¬¦ä¸²**ã€‚è§£ç åæ˜¯ä¸€ä¸ª**æµ®ç‚¹æ•°æ•°ç»„**ï¼Œå½¢çŠ¶ä¸ºï¼š

```
[1, 256, 64, 64] = 1,048,576 ä¸ªæµ®ç‚¹æ•°
```

è½¬æ¢è¿‡ç¨‹ï¼š
```typescript
// 1. ä¸‹è½½å¹¶è§£ç Base64
const base64Str = await fetch(embeddingUrl).then(r => r.text());
const binaryStr = atob(base64Str);

// 2. è½¬ä¸ºUint8Array
const uint8Array = new Uint8Array(binaryStr.length);
for (let i = 0; i < binaryStr.length; i++) {
  uint8Array[i] = binaryStr.charCodeAt(i);
}

// 3. è½¬ä¸ºFloat32Array
const float32Array = new Float32Array(uint8Array.buffer);

// 4. åˆ›å»ºTensorï¼ˆONNXæ ¼å¼ï¼‰
const tensor = new Tensor('float32', float32Array, [1, 256, 64, 64]);
```

#### Embeddingçš„å¤§å°

- **æµ®ç‚¹æ•°ä¸ªæ•°**ï¼š1,048,576
- **æ¯ä¸ªæµ®ç‚¹æ•°**ï¼š4å­—èŠ‚
- **æ€»å¤§å°**ï¼š1,048,576 Ã— 4 = **4,194,304å­—èŠ‚** â‰ˆ **4MB**

### 3.3 ç¬¬äºŒç«™ï¼šç‚¹å‡»æ•°æ®çš„å‡†å¤‡

#### ç‚¹å‡»ç‚¹çš„æ•°æ®ç»“æ„

```typescript
type IClick = [x: number, y: number, type: 0 | 1];
// x, y: ç‚¹å‡»åæ ‡
// type: 1=æ­£ç‚¹ï¼ˆåŒ…å«ï¼‰ï¼Œ0=è´Ÿç‚¹ï¼ˆæ’é™¤ï¼‰
```

ä¾‹å¦‚ï¼š
```typescript
const clicks = [
  [300, 200, 1],  // ç¬¬ä¸€æ¬¡ç‚¹å‡»ï¼šåŒ…å«
  [350, 180, 0],  // ç¬¬äºŒæ¬¡ç‚¹å‡»ï¼šæ’é™¤
];
```

#### åæ ‡å½’ä¸€åŒ–

SAMæ¨¡å‹çš„è¾“å…¥å°ºå¯¸å›ºå®šä¸º `1024Ã—1024`ï¼Œæ‰€ä»¥éœ€è¦å°†åæ ‡å½’ä¸€åŒ–ï¼š

```typescript
// åŸå›¾å°ºå¯¸ï¼š1920Ã—1080
const imageWidth = 1920;
const imageHeight = 1080;

// è®¡ç®—ç¼©æ”¾æ¯”ä¾‹ï¼ˆé•¿è¾¹ç¼©æ”¾åˆ°1024ï¼‰
const scale = 1024 / Math.max(imageWidth, imageHeight);
// scale = 1024 / 1920 = 0.533

// å½’ä¸€åŒ–åæ ‡
const normalizedX = 300 * 0.533 = 160;
const normalizedY = 200 * 0.533 = 107;
```

#### å‡†å¤‡ONNXè¾“å…¥

```typescript
const feeds = {
  // 1. å›¾åƒç‰¹å¾ï¼ˆæ¥è‡ªEmbeddingï¼‰
  image_embeddings: embeddingTensor,  // [1, 256, 64, 64]
  
  // 2. ç‚¹å‡»åæ ‡
  point_coords: new Tensor('float32', [
    160, 107,   // ç¬¬ä¸€ä¸ªç‚¹
    187, 96     // ç¬¬äºŒä¸ªç‚¹
  ], [1, 2, 2]),  // [batch, num_points, 2]
  
  // 3. ç‚¹å‡»ç±»å‹
  point_labels: new Tensor('float32', [
    1,  // ç¬¬ä¸€ä¸ªç‚¹æ˜¯æ­£ç‚¹
    0   // ç¬¬äºŒä¸ªç‚¹æ˜¯è´Ÿç‚¹
  ], [1, 2]),  // [batch, num_points]
  
  // 4. å†å²maskï¼ˆç”¨äºå¢é‡è®¡ç®—ï¼‰
  mask_input: prevMaskTensor || zeros([1, 1, 256, 256]),
  has_mask_input: new Tensor('float32', [prevMask ? 1 : 0], [1]),
  
  // 5. åŸå›¾å°ºå¯¸
  orig_im_size: new Tensor('float32', [1080, 1920], [2])
};
```

### 3.4 ç¬¬ä¸‰ç«™ï¼šONNXæ¨ç†è¾“å‡º

#### æ¨ç†æ‰§è¡Œ

```typescript
const session = await InferenceSession.create('sam_decoder.onnx');
const results = await session.run(feeds);
```

è¿™ä¸€æ­¥ä¼šè€—æ—¶ **50-200ms**ï¼ˆå–å†³äºè®¾å¤‡å’Œæ‰§è¡Œæä¾›è€…ï¼‰ã€‚

#### è¾“å‡ºæ•°æ®ç»“æ„

```typescript
{
  masks: Tensor {
    data: Float32Array(196608),  // 3 * 256 * 256
    dims: [1, 3, 256, 256]
  },
  iou_predictions: Tensor {
    data: Float32Array([0.92, 0.87, 0.78]),
    dims: [1, 3]
  }
}
```

**å…³é”®ç‚¹**ï¼š
- æ¨¡å‹è¾“å‡º**3ä¸ªå€™é€‰mask**
- æ¯ä¸ªmaskæœ‰å¯¹åº”çš„**è´¨é‡è¯„åˆ†**ï¼ˆIOUï¼‰
- æˆ‘ä»¬é€‰æ‹©è¯„åˆ†æœ€é«˜çš„mask

#### é€‰æ‹©æœ€ä½³Mask

```typescript
const masks = results.masks.data;      // Float32Array(196608)
const scores = results.iou_predictions.data;  // [0.92, 0.87, 0.78]

// æ‰¾åˆ°æœ€é«˜åˆ†æ•°çš„ç´¢å¼•
let bestIndex = 0;
let bestScore = scores[0];
for (let i = 1; i < 3; i++) {
  if (scores[i] > bestScore) {
    bestScore = scores[i];
    bestIndex = i;
  }
}

// æå–å¯¹åº”çš„mask
const maskSize = 256 * 256;
const bestMask = masks.slice(
  bestIndex * maskSize,
  (bestIndex + 1) * maskSize
);
```

### 3.5 ç¬¬å››ç«™ï¼šMaskæ•°æ®çš„åå¤„ç†

#### Float32Array â†’ åƒç´ æ•°æ®

```typescript
const width = 256;
const height = 256;
const pixelData = new Uint8ClampedArray(width * height * 4);

for (let i = 0; i < bestMask.length; i++) {
  const value = bestMask[i] > 0 ? 255 : 0;  // é˜ˆå€¼å¤„ç†
  pixelData[i * 4] = value;      // R
  pixelData[i * 4 + 1] = value;  // G
  pixelData[i * 4 + 2] = value;  // B
  pixelData[i * 4 + 3] = value;  // A
}

// ç»˜åˆ¶åˆ°Canvas
const imageData = new ImageData(pixelData, width, height);
ctx.putImageData(imageData, 0, 0);
```

#### ä¸Šé‡‡æ ·åˆ°åŸå›¾å°ºå¯¸

æ¨¡å‹è¾“å‡ºçš„maskæ˜¯ `256Ã—256`ï¼Œéœ€è¦æ”¾å¤§åˆ°åŸå›¾å°ºå¯¸ï¼š

```typescript
// åŸå›¾ï¼š1920Ã—1080
const fullSizeCanvas = document.createElement('canvas');
fullSizeCanvas.width = 1920;
fullSizeCanvas.height = 1080;

const ctx = fullSizeCanvas.getContext('2d');
ctx.drawImage(
  maskCanvas,      // æºï¼š256Ã—256
  0, 0, 256, 256,  // æºåŒºåŸŸ
  0, 0, 1920, 1080 // ç›®æ ‡åŒºåŸŸï¼ˆè‡ªåŠ¨æ‹‰ä¼¸ï¼‰
);
```

#### SVGè½®å»“ç”Ÿæˆï¼ˆå¯é€‰ï¼‰

ä¸ºäº†æ›´å¥½çš„è§†è§‰æ•ˆæœï¼Œå¯ä»¥æå–maskçš„è½®å»“ï¼š

```typescript
// 1. ä½¿ç”¨Marching Squaresç®—æ³•æå–è½®å»“ç‚¹
const contours = findContours(maskData);
// contours: [[[x1,y1], [x2,y2], ...], ...]

// 2. è½¬æ¢ä¸ºSVG Path
const svgPath = contours.map(contour => {
  let path = `M ${contour[0][0]} ${contour[0][1]}`;
  for (let i = 1; i < contour.length; i++) {
    path += ` L ${contour[i][0]} ${contour[i][1]}`;
  }
  path += ' Z';
  return path;
});

// 3. ç»˜åˆ¶è½®å»“
ctx.strokeStyle = 'green';
ctx.lineWidth = 2;
svgPath.forEach(path => {
  ctx.stroke(new Path2D(path));
});
```

---

# ç¬¬ä¸‰éƒ¨åˆ†ï¼šå®ç°å‰–æ

## ç¬¬å››ç« ï¼šRLEæ•°æ®çš„è§£ç å®ç°

### 4.1 ä¸ºä»€ä¹ˆéœ€è¦æ·±å…¥ç†è§£RLEï¼Ÿ

åœ¨ç¬¬äºŒç« æˆ‘ä»¬çŸ¥é“äº†RLEçš„åŸºæœ¬è§£ç æµç¨‹ï¼Œä½†å®é™…å®ç°ä¸­æœ‰å¾ˆå¤šç»†èŠ‚ï¼š
- å¦‚ä½•å¤„ç†åæ ‡æ—‹è½¬ï¼Ÿ
- å¦‚ä½•ä¼˜åŒ–è§£ç æ€§èƒ½ï¼Ÿ
- å¦‚ä½•å¤„ç†è¾¹ç•Œæƒ…å†µï¼Ÿ

### 4.2 å®Œæ•´çš„è§£ç å®ç°

```typescript
function rleToMask(
  counts: number[],
  width: number,
  height: number,
  color: [number, number, number, number]
): HTMLCanvasElement {
  
  // === é˜¶æ®µ1ï¼šåˆ›å»ºä¸´æ—¶Canvasï¼ˆæ³¨æ„å®½é«˜äº’æ¢ï¼‰===
  const tempCanvas = document.createElement('canvas');
  tempCanvas.width = height;    // ç”¨heightä½œä¸ºå®½åº¦
  tempCanvas.height = width;    // ç”¨widthä½œä¸ºé«˜åº¦
  
  const tempCtx = tempCanvas.getContext('2d', {
    willReadFrequently: true  // æ€§èƒ½ä¼˜åŒ–æç¤º
  });
  
  // === é˜¶æ®µ2ï¼šåˆ›å»ºåƒç´ æ•°ç»„ ===
  const imageData = tempCtx.createImageData(height, width);
  const data = imageData.data;
  
  // === é˜¶æ®µ3ï¼šRLEè§£ç  ===
  let position = 0;
  
  for (let i = 0; i < counts.length; i += 2) {
    const zeros = counts[i];      // è·³è¿‡çš„åƒç´ æ•°
    const ones = counts[i + 1];   // å¡«å……çš„åƒç´ æ•°
    
    // è·³è¿‡zerosä¸ªåƒç´ 
    position += zeros;
    
    // å¡«å……onesä¸ªåƒç´ 
    for (let j = 0; j < ones; j++) {
      const idx = position * 4;
      data[idx] = color[0];      // R
      data[idx + 1] = color[1];  // G
      data[idx + 2] = color[2];  // B
      data[idx + 3] = color[3];  // A
      position++;
    }
  }
  
  // === é˜¶æ®µ4ï¼šç»˜åˆ¶åˆ°ä¸´æ—¶Canvas ===
  tempCtx.putImageData(imageData, 0, 0);
  
  // === é˜¶æ®µ5ï¼šæ—‹è½¬æ ¡æ­£ ===
  const finalCanvas = document.createElement('canvas');
  finalCanvas.width = width;
  finalCanvas.height = height;
  
  const finalCtx = finalCanvas.getContext('2d');
  finalCtx.save();
  
  // æ—‹è½¬å˜æ¢çŸ©é˜µ
  finalCtx.scale(1, -1);                    // Yè½´ç¿»è½¬
  finalCtx.rotate(-90 * Math.PI / 180);    // é€†æ—¶é’ˆæ—‹è½¬90åº¦
  finalCtx.drawImage(tempCanvas, 0, 0);
  
  finalCtx.restore();
  
  // === é˜¶æ®µ6ï¼šæ¸…ç†ä¸´æ—¶Canvas ===
  tempCanvas.width = 1;
  tempCanvas.height = 1;
  
  return finalCanvas;
}
```

### 4.3 å…³é”®ç‚¹æ·±åº¦è§£æ

#### ä¸ºä»€ä¹ˆå®½é«˜è¦äº’æ¢ï¼Ÿ

SAMçš„RLEæ•°æ®æ˜¯**åˆ—ä¼˜å…ˆ**å­˜å‚¨çš„ï¼Œæƒ³è±¡ä¸€ä¸ª 3Ã—4 çš„å›¾åƒï¼š

```
åŸå§‹å›¾åƒï¼ˆè¡Œä¼˜å…ˆï¼‰ï¼š     SAMå­˜å‚¨ï¼ˆåˆ—ä¼˜å…ˆï¼‰ï¼š
1  2  3  4              1  5   9
5  6  7  8              2  6  10
9 10 11 12              3  7  11
                        4  8  12
```

æ‰€ä»¥è§£ç æ—¶ï¼Œåˆ›å»ºçš„ä¸´æ—¶Canvasæ˜¯ **4Ã—3**ï¼ˆå®½é«˜äº’æ¢ï¼‰ã€‚

#### æ—‹è½¬å˜æ¢çš„æ•°å­¦åŸç†

```typescript
// åŸç‚¹åœ¨å·¦ä¸Šè§’ï¼ŒYè½´å‘ä¸‹
scale(1, -1)    // Yè½´ç¿»è½¬ï¼ŒåŸç‚¹ç§»åˆ°å·¦ä¸‹
rotate(-90Â°)    // é€†æ—¶é’ˆæ—‹è½¬90åº¦
```

ç”¨å˜æ¢çŸ©é˜µè¡¨ç¤ºï¼š
```
[1   0 ]   [cos(-90)  -sin(-90)]   [0   1]
[0  -1] Ã— [sin(-90)   cos(-90)] = [1   0]
```

#### æ€§èƒ½ä¼˜åŒ–æŠ€å·§

1. **é¿å…é¢‘ç¹åˆ›å»ºImageData**
```typescript
// âŒ æ¯æ¬¡éƒ½åˆ›å»ºï¼ˆæ…¢ï¼‰
for (let layer of layers) {
  const imageData = ctx.createImageData(w, h);
  // ...
}

// âœ… å¤ç”¨ImageDataï¼ˆå¿«ï¼‰
const imageData = ctx.createImageData(w, h);
for (let layer of layers) {
  // ç›´æ¥ä¿®æ”¹imageData.data
  // ...
  ctx.putImageData(imageData, 0, 0);
}
```

2. **ä½¿ç”¨Typed Arrayçš„å­æ•°ç»„è§†å›¾**
```typescript
// âŒ é€ä¸ªèµ‹å€¼ï¼ˆæ…¢ï¼‰
for (let i = 0; i < ones; i++) {
  data[pos*4] = 255;
  data[pos*4+1] = 255;
  data[pos*4+2] = 255;
  data[pos*4+3] = 255;
  pos++;
}

// âœ… æ‰¹é‡å¡«å……ï¼ˆå¿«ï¼‰
const rgba = new Uint8Array([255, 255, 255, 255]);
for (let i = 0; i < ones; i++) {
  data.set(rgba, pos * 4);
  pos++;
}
```

---

## ç¬¬äº”ç« ï¼šé¢œè‰²IDæ‹¾å–ç³»ç»Ÿçš„å®ç°

### 5.1 é¢œè‰²IDç”Ÿæˆå™¨çš„å®ç°

```typescript
class ColorIdService {
  private static instance: ColorIdService;
  private currentId = 0;
  private colorMap = new Map<string, [number, number, number, number]>();
  
  static getInstance() {
    if (!ColorIdService.instance) {
      ColorIdService.instance = new ColorIdService();
    }
    return ColorIdService.instance;
  }
  
  generateID(): [string, [number, number, number, number]] {
    this.currentId++;
    
    // å°†IDç¼–ç ä¸ºRGBï¼ˆ24ä½è‰²å½©ç©ºé—´ï¼‰
    const r = (this.currentId >>> 16) & 0xFF;  // é«˜8ä½
    const g = (this.currentId >>> 8) & 0xFF;   // ä¸­8ä½
    const b = this.currentId & 0xFF;           // ä½8ä½
    
    const id = this.currentId.toString();
    const color: [number, number, number, number] = [r, g, b, 255];
    
    this.colorMap.set(id, color);
    
    return [id, color];
  }
  
  checkColorDistance(
    color1: Uint8ClampedArray | number[],
    color2: Uint8ClampedArray | number[]
  ): number {
    const dr = color1[0] - color2[0];
    const dg = color1[1] - color2[1];
    const db = color1[2] - color2[2];
    const da = color1[3] - color2[3];
    
    return Math.sqrt(dr*dr + dg*dg + db*db + da*da);
  }
}
```

### 5.2 PickCanvasçš„æ„å»º

```typescript
class AutoMaskModel {
  private pickCanvas: HTMLCanvasElement;
  private layerMap = new Map<string, AutoMaskLayer>();
  
  constructor(autoMasks: IAutoMask[], image: HTMLImageElement) {
    const colorService = ColorIdService.getInstance();
    
    // 1. åˆ›å»ºpickCanvas
    this.pickCanvas = document.createElement('canvas');
    this.pickCanvas.width = autoMasks[0].segmentation.size[1];
    this.pickCanvas.height = autoMasks[0].segmentation.size[0];
    
    const pickCtx = this.pickCanvas.getContext('2d');
    
    // 2. æŒ‰é¢ç§¯ä»å¤§åˆ°å°æ’åºï¼ˆé‡è¦ï¼ï¼‰
    autoMasks.sort((a, b) => b.area - a.area);
    
    // 3. ä¸ºæ¯å±‚ç”Ÿæˆé¢œè‰²IDå¹¶ç»˜åˆ¶åˆ°pickCanvas
    this.layers = autoMasks.map(mask => {
      const [id, color] = colorService.generateID();
      
      // è§£ç RLEï¼Œä½¿ç”¨å”¯ä¸€é¢œè‰²
      const maskCanvas = rleToMask(
        mask.segmentation.counts,
        mask.segmentation.size[1],
        mask.segmentation.size[0],
        color  // ä½¿ç”¨é¢œè‰²ID
      );
      
      // ç»˜åˆ¶åˆ°pickCanvas
      pickCtx.drawImage(maskCanvas, 0, 0);
      
      const layer = {
        id,
        color,
        mode: null,
        area: mask.area,
        maskCanvas,
        segmentation: mask.segmentation
      };
      
      this.layerMap.set(id, layer);
      return layer;
    });
  }
}
```

### 5.3 ä¸ºä»€ä¹ˆè¦æŒ‰é¢ç§¯æ’åºï¼Ÿ

è€ƒè™‘è¿™ä¸ªåœºæ™¯ï¼š
- å¤§å±‚ï¼šæ•´åªçŒ«ï¼ˆé¢ç§¯10000ï¼‰
- å°å±‚ï¼šçŒ«çš„è€³æœµï¼ˆé¢ç§¯500ï¼‰

å¦‚æœå…ˆç»˜åˆ¶å°å±‚ï¼Œå†ç»˜åˆ¶å¤§å±‚ï¼Œé‚£ä¹ˆpickCanvasä¸Š**å°å±‚ä¼šè¢«è¦†ç›–**ï¼Œç”¨æˆ·ç‚¹å‡»è€³æœµæ—¶ä¼šåŒ¹é…åˆ°å¤§å±‚ï¼Œè¿™æ˜¯é”™è¯¯çš„ã€‚

æ­£ç¡®é¡ºåºï¼š**ä»å¤§åˆ°å°**ç»˜åˆ¶ï¼Œå°å±‚ä¼šè¦†ç›–å¤§å±‚ï¼Œç¡®ä¿ä¼˜å…ˆåŒ¹é…æœ€ç²¾ç¡®çš„å±‚ã€‚

### 5.4 ç‚¹å‡»æ‹¾å–çš„å®Œæ•´å®ç°

```typescript
pickLayer(x: number, y: number): AutoMaskLayer | null {
  // 1. åæ ‡è½¬æ¢
  const scale = this.pickCanvas.width / this.image.naturalWidth;
  const canvasX = Math.floor(x * scale);
  const canvasY = Math.floor(y * scale);
  
  // è¾¹ç•Œæ£€æŸ¥
  if (canvasX < 0 || canvasX >= this.pickCanvas.width ||
      canvasY < 0 || canvasY >= this.pickCanvas.height) {
    return null;
  }
  
  // 2. è¯»å–é¢œè‰²
  const ctx = this.pickCanvas.getContext('2d');
  const pixel = ctx.getImageData(canvasX, canvasY, 1, 1);
  
  // 3. é¢œè‰²åŒ¹é…
  const colorService = ColorIdService.getInstance();
  let minDistance = Infinity;
  let matchedLayer: AutoMaskLayer | null = null;
  
  for (let layer of this.layers) {
    const distance = colorService.checkColorDistance(layer.color, pixel.data);
    
    // é˜ˆå€¼3ï¼šå…è®¸è½»å¾®è‰²å·®
    if (distance < 3 && distance < minDistance) {
      minDistance = distance;
      matchedLayer = layer;
    }
  }
  
  return matchedLayer;
}
```

---

## ç¬¬å…­ç« ï¼šå›¾å±‚åˆæˆçš„å®ç°

### 6.1 Canvasæ··åˆæ¨¡å¼è¯¦è§£

Canvasçš„ `globalCompositeOperation` å†³å®šäº†æ–°å†…å®¹å¦‚ä½•ä¸å·²æœ‰å†…å®¹æ··åˆã€‚

#### æ ¸å¿ƒæ¨¡å¼å¯¹æ¯”

```typescript
ctx.globalCompositeOperation = 'source-over';
// æºï¼ˆæ–°å†…å®¹ï¼‰è¦†ç›–åœ¨ç›®æ ‡ï¼ˆæ—§å†…å®¹ï¼‰ä¹‹ä¸Š
// ç»“æœ = æº + (1-æºé€æ˜åº¦)*ç›®æ ‡

ctx.globalCompositeOperation = 'destination-out';
// æºçš„å½¢çŠ¶ä»ç›®æ ‡ä¸­"æŒ–"å‡ºæ¥
// ç»“æœ = (1-æºé€æ˜åº¦)*ç›®æ ‡
```

ç”¨å›¾ç¤ºè¯´æ˜ï¼š

```
å·²æœ‰å†…å®¹ï¼ˆç›®æ ‡ï¼‰ï¼š     æ–°å†…å®¹ï¼ˆæºï¼‰ï¼š       source-overï¼š      destination-outï¼š
â– â– â– â– â– â– â–             â—â—â—â—              â– â– â– â– â– â– â–           â– â– â– â– â– â– â– 
â– â– â– â– â– â– â–             â—â—â—â—              â– â—â—â—â– â– â–           â– â–¡â–¡â–¡â– â– â– 
â– â– â– â– â– â– â–             â—â—â—â—              â– â—â—â—â– â– â–           â– â–¡â–¡â–¡â– â– â– 
â– â– â– â– â– â– â–             â—â—â—â—              â– â– â– â– â– â– â–           â– â– â– â– â– â– â– 
```

### 6.2 æ™ºèƒ½æ¨¡å¼åˆ‡æ¢çš„å®ç°

```typescript
toggleLayerMode(x: number, y: number): AutoMaskResult | null {
  const layer = this.pickLayer(x, y);
  if (!layer) return null;
  
  // æŸ¥æ‰¾è¯¥ä½ç½®å…¶ä»–å·²é€‰ä¸­çš„å±‚
  const overlappingLayers = this.findOverlappingSelectedLayers(x, y, layer);
  
  if (overlappingLayers.length === 0) {
    // === æƒ…å†µ1ï¼šç‹¬ç«‹åŒºåŸŸ ===
    // null â†’ source-over â†’ null
    layer.mode = layer.mode === 'source-over' ? null : 'source-over';
  } else {
    // === æƒ…å†µ2ï¼šåœ¨å…¶ä»–å±‚å†…éƒ¨ ===
    // æ‰¾åˆ°åŒ…å«å½“å‰å±‚çš„æœ€å¤§å±‚
    const containerLayer = overlappingLayers.find(
      l => l.area > layer.area && l.mode === 'source-over'
    );
    
    if (containerLayer) {
      // åœ¨æ­£é€‰å±‚å†…éƒ¨ï¼šnull â†’ destination-out â†’ null
      if (layer.mode === null) {
        layer.mode = 'destination-out';
      } else if (layer.mode === 'destination-out') {
        layer.mode = null;
      } else {
        layer.mode = null;
      }
    } else {
      // åœ¨è´Ÿé€‰å±‚å†…éƒ¨ï¼šæ­£å¸¸åˆ‡æ¢
      layer.mode = layer.mode === 'source-over' ? null : 'source-over';
    }
  }
  
  return this.getMaskResult();
}

private findOverlappingSelectedLayers(
  x: number,
  y: number,
  excludeLayer: AutoMaskLayer
): AutoMaskLayer[] {
  const scale = this.pickCanvas.width / this.image.naturalWidth;
  const canvasX = Math.floor(x * scale);
  const canvasY = Math.floor(y * scale);
  
  return this.layers.filter(layer => {
    if (layer === excludeLayer || layer.mode === null) return false;
    
    // æ£€æŸ¥è¯¥å±‚åœ¨ç‚¹å‡»ä½ç½®æ˜¯å¦æœ‰åƒç´ 
    const ctx = layer.maskCanvas.getContext('2d');
    const pixel = ctx.getImageData(canvasX, canvasY, 1, 1);
    return pixel.data[3] > 0;  // alpha > 0 è¡¨ç¤ºæœ‰åƒç´ 
  });
}
```

### 6.3 æœ€ç»ˆåˆæˆçš„å®ç°

```typescript
getMaskResult(): AutoMaskResult | null {
  // æ£€æŸ¥æ˜¯å¦æœ‰é€‰ä¸­çš„å±‚
  const hasSelectedLayers = this.layers.some(l => l.mode !== null);
  if (!hasSelectedLayers) return null;
  
  // åˆ›å»ºç»“æœCanvas
  const resultCanvas = document.createElement('canvas');
  resultCanvas.width = this.image.naturalWidth;
  resultCanvas.height = this.image.naturalHeight;
  
  const ctx = resultCanvas.getContext('2d');
  ctx.save();
  
  // æŒ‰é¡ºåºåˆæˆæ‰€æœ‰é€‰ä¸­çš„å±‚
  for (let layer of this.layers) {
    if (layer.mode !== null) {
      ctx.globalCompositeOperation = layer.mode;
      
      // ç¼©æ”¾ç»˜åˆ¶ï¼ˆlayerçš„Canvaså¯èƒ½å°ºå¯¸ä¸åŒï¼‰
      ctx.drawImage(
        layer.maskCanvas,
        0, 0, layer.maskCanvas.width, layer.maskCanvas.height,
        0, 0, resultCanvas.width, resultCanvas.height
      );
    }
  }
  
  ctx.restore();
  
  return new AutoMaskResult(this.image, this.layers.filter(l => l.mode !== null));
}
```

---

## ç¬¬ä¸ƒç« ï¼šONNXæ¨ç†çš„å®ç°

### 7.1 æ¨¡å‹åŠ è½½ä¸ç¼“å­˜

```typescript
class OnnxModelService {
  private static modelCache: InferenceSession | null = null;
  private static loadingPromise: Promise<InferenceSession> | null = null;
  
  static async getModel(options?: { onnxUrl?: string }): Promise<InferenceSession> {
    // å¦‚æœå·²åŠ è½½ï¼Œç›´æ¥è¿”å›
    if (this.modelCache) {
      return this.modelCache;
    }
    
    // å¦‚æœæ­£åœ¨åŠ è½½ï¼Œç­‰å¾…åŠ è½½å®Œæˆ
    if (this.loadingPromise) {
      return this.loadingPromise;
    }
    
    // å¼€å§‹åŠ è½½
    this.loadingPromise = (async () => {
      const modelUrl = options?.onnxUrl || '/default-sam-decoder.onnx';
      
      // é…ç½®æ‰§è¡Œæä¾›è€…ï¼ˆä¼˜å…ˆçº§ï¼šwebgpu > wasm > cpuï¼‰
      const executionProviders = ['webgpu', 'wasm', 'cpu'];
      
      this.modelCache = await InferenceSession.create(modelUrl, {
        executionProviders
      });
      
      return this.modelCache;
    })();
    
    return this.loadingPromise;
  }
}
```

### 7.2 è¾“å…¥æ•°æ®å‡†å¤‡

```typescript
function toModelData(
  clicks: IClick[],
  imageTensor: Tensor,
  modelScale: ModelScale,
  prevMask: Tensor | null
): Record<string, Tensor> {
  
  const numClicks = clicks.length;
  
  // 1. å‡†å¤‡ç‚¹å‡»åæ ‡
  const coords = new Float32Array(numClicks * 2);
  const labels = new Float32Array(numClicks);
  
  for (let i = 0; i < numClicks; i++) {
    const [x, y, label] = clicks[i];
    
    // åæ ‡å½’ä¸€åŒ–
    coords[i * 2] = x * modelScale.samScale;
    coords[i * 2 + 1] = y * modelScale.samScale;
    
    labels[i] = label;
  }
  
  // 2. å‡†å¤‡maskè¾“å…¥
  const hasMask = prevMask !== null;
  const maskInput = hasMask 
    ? prevMask 
    : new Tensor('float32', new Float32Array(1 * 1 * 256 * 256), [1, 1, 256, 256]);
  
  // 3. ç»„è£…æ‰€æœ‰è¾“å…¥
  return {
    image_embeddings: imageTensor,
    point_coords: new Tensor('float32', coords, [1, numClicks, 2]),
    point_labels: new Tensor('float32', labels, [1, numClicks]),
    mask_input: maskInput,
    has_mask_input: new Tensor('float32', [hasMask ? 1 : 0], [1]),
    orig_im_size: new Tensor('float32', [
      modelScale.height,
      modelScale.width
    ], [2])
  };
}
```

### 7.3 æ¨ç†ä¸ç»“æœå¤„ç†

```typescript
class SamModel {
  private async predict(
    clicks: IClick[],
    prevMask: Tensor | null
  ): Promise<{ mask: Float32Array, predMask: Tensor }> {
    
    // 1. åŠ è½½æ¨¡å‹
    const model = await OnnxModelService.getModel();
    
    // 2. å‡†å¤‡è¾“å…¥
    const feeds = toModelData(clicks, this.embedding, this.modelScale, prevMask);
    
    // 3. æ‰§è¡Œæ¨ç†
    const startTime = performance.now();
    const results = await model.run(feeds);
    const inferenceTime = performance.now() - startTime;
    console.log(`æ¨ç†è€—æ—¶: ${inferenceTime.toFixed(2)}ms`);
    
    // 4. æå–è¾“å‡º
    const masksOutput = results[model.outputNames[0]];   // 'masks'
    const scoresOutput = results[model.outputNames[1]];  // 'iou_predictions'
    const predMaskOutput = results[model.outputNames[2]]; // ä½åˆ†è¾¨ç‡maskï¼ˆç”¨äºä¸‹æ¬¡è¾“å…¥ï¼‰
    
    // 5. é€‰æ‹©æœ€ä½³mask
    const { mask, predMask } = getBestMask(
      masksOutput.data as Float32Array,
      masksOutput.dims[2],  // height: 256
      masksOutput.dims[3],  // width: 256
      scoresOutput.data as Float32Array,
      predMaskOutput.data as Float32Array,
      predMaskOutput.dims[2],  // height: 256
      predMaskOutput.dims[3]   // width: 256
    );
    
    return { mask, predMask };
  }
}
```

### 7.4 æœ€ä½³Maské€‰æ‹©

```typescript
function getBestMask(
  masks: Float32Array,      // [3, 256, 256]
  maskHeight: number,
  maskWidth: number,
  scores: Float32Array,     // [3]
  predMasks: Float32Array,  // [3, 256, 256]
  predHeight: number,
  predWidth: number
): { mask: Float32Array, predMask: Tensor } {
  
  // 1. æ‰¾åˆ°æœ€é«˜åˆ†æ•°
  let bestIdx = 0;
  let bestScore = scores[0];
  
  for (let i = 1; i < scores.length; i++) {
    if (scores[i] > bestScore) {
      bestScore = scores[i];
      bestIdx = i;
    }
  }
  
  // 2. æå–å¯¹åº”çš„mask
  const maskSize = maskHeight * maskWidth;
  const mask = masks.slice(
    bestIdx * maskSize,
    (bestIdx + 1) * maskSize
  );
  
  // 3. æå–å¯¹åº”çš„predMaskï¼ˆç”¨äºä¸‹æ¬¡æ¨ç†ï¼‰
  const predMaskSize = predHeight * predWidth;
  const predMaskData = predMasks.slice(
    bestIdx * predMaskSize,
    (bestIdx + 1) * predMaskSize
  );
  
  const predMask = new Tensor(
    'float32',
    predMaskData,
    [1, 1, predHeight, predWidth]
  );
  
  return { mask, predMask };
}
```

### 7.5 å†å²ç®¡ç†çš„å®ç°

```typescript
class SamModel {
  private clicks: IClick[] = [];
  private predMask: Tensor | null = null;
  private history: Array<{ clicks: IClick[], predMask: Tensor | null }> = [];
  private historyCursor = 0;
  
  async addClick(click: IClick, snapshot = false): Promise<MaskResult | null> {
    // æ‹’ç»æ— æ•ˆçš„è´Ÿç‚¹
    if (click[2] === 0 && this.clicks.length === 0) {
      return null;
    }
    
    // æ‰§è¡Œæ¨ç†
    const newClicks = [...this.clicks, click];
    const { mask, predMask } = await this.predict(newClicks, this.predMask);
    
    // ä¿å­˜å¿«ç…§
    if (snapshot) {
      // åˆ é™¤å½“å‰æ¸¸æ ‡åçš„å†å²
      if (this.history.length > this.historyCursor) {
        this.history.splice(this.historyCursor);
      }
      
      // æ·»åŠ æ–°å¿«ç…§
      this.history.push({ clicks: newClicks, predMask });
      this.historyCursor++;
      
      // æ›´æ–°çŠ¶æ€
      this.clicks = newClicks;
      this.predMask = predMask;
    }
    
    return new MaskResult(newClicks, this.image, mask);
  }
  
  async setClicks(clicks: IClick[]): Promise<void> {
    // æŸ¥æ‰¾å†å²ä¸­çš„åŒ¹é…ç‚¹
    const matchIndex = this.findHistoryMatch(clicks);
    
    if (matchIndex !== -1 && matchIndex === clicks.length) {
      // å®Œå…¨åŒ¹é…ï¼Œç›´æ¥æ¢å¤å†å²çŠ¶æ€
      const snapshot = this.history[matchIndex - 1];
      this.clicks = snapshot.clicks;
      this.predMask = snapshot.predMask;
      this.historyCursor = matchIndex;
    } else {
      // ä¸åŒ¹é…ï¼Œé‡æ–°æ¨ç†
      this.predMask = null;
      for (let i = 0; i < clicks.length; i++) {
        const result = await this._addClick(clicks[i]);
        this.predMask = result.predMask;
        this.clicks = result.clicks;
      }
      this.history = [{ clicks: [...this.clicks], predMask: this.predMask }];
      this.historyCursor = 1;
    }
  }
  
  private findHistoryMatch(clicks: IClick[]): number {
    for (let i = 0; i < this.history.length; i++) {
      const snapshot = this.history[i];
      
      // æ£€æŸ¥å‰i+1ä¸ªç‚¹å‡»æ˜¯å¦åŒ¹é…
      if (i + 1 > clicks.length) break;
      
      let match = true;
      for (let j = 0; j <= i; j++) {
        const c1 = clicks[j];
        const c2 = snapshot.clicks[j];
        if (c1[0] !== c2[0] || c1[1] !== c2[1] || c1[2] !== c2[2]) {
          match = false;
          break;
        }
      }
      
      if (match && i + 1 === clicks.length) {
        return i + 1;
      }
      if (!match) {
        return -1;
      }
    }
    return -1;
  }
}
```

---

# ç¬¬å››éƒ¨åˆ†ï¼šåŸç†æ·±åº¦å‰–æ

## ç¬¬å…«ç« ï¼šSAMæ¨¡å‹çš„å·¥ä½œåŸç†

### 8.1 ä»€ä¹ˆæ˜¯SAMï¼Ÿ

SAMï¼ˆSegment Anything Modelï¼‰æ˜¯Meta AIåœ¨2023å¹´å‘å¸ƒçš„é©å‘½æ€§å›¾åƒåˆ†å‰²æ¨¡å‹ã€‚å®ƒçš„æ ¸å¿ƒåˆ›æ–°æ˜¯**æç¤ºå¼åˆ†å‰²èŒƒå¼**ã€‚

#### ä¼ ç»Ÿåˆ†å‰² vs SAMåˆ†å‰²

**ä¼ ç»Ÿåˆ†å‰²**ï¼š
```
è®­ç»ƒæ•°æ®ï¼šçŒ«çš„å›¾ç‰‡ â†’ æ¨¡å‹ â†’ åªèƒ½åˆ†å‰²çŒ«
è®­ç»ƒæ•°æ®ï¼šç‹—çš„å›¾ç‰‡ â†’ æ¨¡å‹ â†’ åªèƒ½åˆ†å‰²ç‹—
```
éœ€è¦ä¸ºæ¯ä¸ªç±»åˆ«è®­ç»ƒä¸“é—¨çš„æ¨¡å‹ã€‚

**SAMåˆ†å‰²**ï¼š
```
è®­ç»ƒæ•°æ®ï¼š10äº¿+æ ‡æ³¨å›¾ç‰‡ â†’ SAM â†’ å¯ä»¥åˆ†å‰²ä»»ä½•ç‰©ä½“
ç”¨æˆ·æç¤ºï¼šç‚¹å‡»ç‚¹/æ¡†é€‰ â†’ SAM â†’ ç”Ÿæˆå¯¹åº”çš„mask
```
ä¸€ä¸ªæ¨¡å‹å¤„ç†æ‰€æœ‰å¯¹è±¡ï¼Œé€šè¿‡"æç¤º"å‘Šè¯‰æ¨¡å‹è¦åˆ†å‰²ä»€ä¹ˆã€‚

### 8.2 SAMçš„ä¸‰å±‚æ¶æ„

```
è¾“å…¥å›¾åƒ â†’ Image Encoder â†’ Image Embedding (1Ã—256Ã—64Ã—64)
                                    â†“
ç”¨æˆ·ç‚¹å‡» â†’ Prompt Encoder â†’ Prompt Embedding
                                    â†“
                            Mask Decoder â†’ è¾“å‡ºMask
```

#### ç¬¬ä¸€å±‚ï¼šImage Encoderï¼ˆå›¾åƒç¼–ç å™¨ï¼‰

**ä½œç”¨**ï¼šå°†å›¾åƒè½¬æ¢ä¸ºé«˜ç»´ç‰¹å¾è¡¨ç¤ºï¼ˆEmbeddingï¼‰

**æ¶æ„**ï¼šVision Transformerï¼ˆViT-Hï¼‰
- å‚æ•°é‡ï¼šçº¦6äº¿
- è¾“å…¥ï¼š1024Ã—1024 RGBå›¾åƒ
- è¾“å‡ºï¼š256Ã—64Ã—64 ç‰¹å¾å›¾

**å·¥ä½œæµç¨‹**ï¼š
1. å°†å›¾åƒåˆ†å‰²ä¸º16Ã—16çš„patchesï¼ˆå…±4096ä¸ªpatchesï¼‰
2. æ¯ä¸ªpatché€šè¿‡çº¿æ€§æŠ•å½±å¾—åˆ°ä¸€ä¸ªå‘é‡
3. æ·»åŠ ä½ç½®ç¼–ç 
4. ç»è¿‡32å±‚Transformerå¤„ç†
5. è¾“å‡º256é€šé“çš„64Ã—64ç‰¹å¾å›¾

**å…³é”®ç‰¹æ€§**ï¼š
- åªéœ€è¿è¡Œ**ä¸€æ¬¡**ï¼ˆé‡é‡çº§è®¡ç®—ï¼‰
- è¾“å‡ºçš„EmbeddingåŒ…å«å›¾åƒæ‰€æœ‰è¯­ä¹‰ä¿¡æ¯
- å¯å¤ç”¨äºå¤šæ¬¡åˆ†å‰²ï¼ˆå¤šä¸ªç‚¹å‡»å…±äº«åŒä¸€ä¸ªEmbeddingï¼‰

#### ç¬¬äºŒå±‚ï¼šPrompt Encoderï¼ˆæç¤ºç¼–ç å™¨ï¼‰

**ä½œç”¨**ï¼šå°†ç”¨æˆ·çš„æç¤ºï¼ˆç‚¹å‡»ã€æ¡†é€‰ï¼‰ç¼–ç ä¸ºå‘é‡

**æ”¯æŒçš„æç¤ºç±»å‹**ï¼š
1. **ç‚¹æç¤º**ï¼š`(x, y, type)` â†’ ä½ç½®ç¼–ç  + ç±»å‹åµŒå…¥
2. **æ¡†æç¤º**ï¼š`(x1, y1, x2, y2)` â†’ å››ä¸ªè§’ç‚¹çš„ä½ç½®ç¼–ç 
3. **Maskæç¤º**ï¼šç²—ç³™çš„mask â†’ å·ç§¯ç¼–ç 

**å·¥ä½œæµç¨‹**ï¼ˆä»¥ç‚¹æç¤ºä¸ºä¾‹ï¼‰ï¼š
```typescript
// ä½ç½®ç¼–ç ï¼ˆç±»ä¼¼Transformerï¼‰
function positionalEncoding(x, y) {
  const pe = [];
  for (let i = 0; i < 128; i++) {
    const freq = 2 ** i;
    pe.push(sin(x * freq * Math.PI));
    pe.push(cos(x * freq * Math.PI));
    pe.push(sin(y * freq * Math.PI));
    pe.push(cos(y * freq * Math.PI));
  }
  return pe;
}

// ç±»å‹åµŒå…¥
const typeEmbedding = {
  foreground: [1, 0],  // æ­£ç‚¹
  background: [0, 1]   // è´Ÿç‚¹
};

// æœ€ç»ˆç¼–ç 
const promptEmbedding = concat(
  positionalEncoding(x, y),
  typeEmbedding[type]
);
```

#### ç¬¬ä¸‰å±‚ï¼šMask Decoderï¼ˆæ©ç è§£ç å™¨ï¼‰

**ä½œç”¨**ï¼šç»“åˆImage Embeddingå’ŒPrompt Embeddingï¼Œç”Ÿæˆåˆ†å‰²mask

**æ¶æ„**ï¼šè½»é‡çº§Transformer + ä¸Šé‡‡æ ·å±‚
- å‚æ•°é‡ï¼šçº¦400ä¸‡ï¼ˆåªæœ‰Encoderçš„1/150ï¼‰
- è¾“å…¥ï¼šImage Embedding (256Ã—64Ã—64) + Prompt Embedding
- è¾“å‡ºï¼š3ä¸ªå€™é€‰Mask (3Ã—256Ã—256) + è´¨é‡è¯„åˆ† (3Ã—1)

**ä¸ºä»€ä¹ˆè¾“å‡º3ä¸ªMaskï¼Ÿ**

è€ƒè™‘è¿™ä¸ªåœºæ™¯ï¼šç”¨æˆ·ç‚¹å‡»äº†ç‹—çš„å¤´éƒ¨

- **Mask 1**ï¼šåªåˆ†å‰²ç‹—å¤´ï¼ˆæœ€ç²¾ç¡®ï¼‰
- **Mask 2**ï¼šåˆ†å‰²æ•´åªç‹—ï¼ˆä¸­ç­‰èŒƒå›´ï¼‰
- **Mask 3**ï¼šåˆ†å‰²ç‹—å’Œå‘¨å›´ç¯å¢ƒï¼ˆæœ€å¤§èŒƒå›´ï¼‰

æ¨¡å‹åŒæ—¶è¾“å‡ºå¤šä¸ªæ­§ä¹‰è§£ï¼Œè®©è´¨é‡è¯„åˆ†è‡ªåŠ¨é€‰æ‹©æœ€ä½³çš„ã€‚

**è´¨é‡è¯„åˆ†ï¼ˆIOU Predictionï¼‰**ï¼š
- é¢„æµ‹"ç”Ÿæˆçš„maskä¸çœŸå®maskçš„é‡å åº¦"
- èŒƒå›´ï¼š0-1ï¼Œè¶Šé«˜è¶Šå¥½
- ç”¨äºè‡ªåŠ¨é€‰æ‹©æœ€ä½³mask

### 8.3 è®­ç»ƒç­–ç•¥

SAMçš„è®­ç»ƒé‡‡ç”¨äº†**æ•°æ®å¼•æ“**çš„åˆ›æ–°æ–¹æ³•ï¼š

```
ç¬¬ä¸€é˜¶æ®µï¼ˆAssisted Manualï¼‰ï¼š
äººå·¥æ ‡æ³¨å‘˜æ‰‹åŠ¨æ ‡æ³¨ â†’ 4.3M masks

ç¬¬äºŒé˜¶æ®µï¼ˆSemi-Automaticï¼‰ï¼š
æ¨¡å‹é¢„æµ‹ + äººå·¥æ ¡æ­£ â†’ 10.2M masks

ç¬¬ä¸‰é˜¶æ®µï¼ˆFully Automaticï¼‰ï¼š
æ¨¡å‹è‡ªåŠ¨ç”Ÿæˆ â†’ 1.1B masks
```

**æ•°æ®è§„æ¨¡**ï¼š
- å›¾ç‰‡æ•°é‡ï¼š1100ä¸‡å¼ 
- Maskæ•°é‡ï¼š11äº¿ä¸ª
- æ•°æ®é›†å¤§å°ï¼šçº¦400GB

### 8.4 ä¸ºä»€ä¹ˆSAMé€‚åˆWebç«¯ï¼Ÿ

**ä¼ ç»Ÿæ·±åº¦å­¦ä¹ æ¨¡å‹åœ¨Webç«¯çš„é—®é¢˜**ï¼š
1. æ¨¡å‹å¤ªå¤§ï¼ˆå‡ ç™¾MBåˆ°å‡ GBï¼‰
2. æ¨ç†å¤ªæ…¢ï¼ˆç§’çº§å»¶è¿Ÿï¼‰
3. æ— æ³•äº¤äº’å¼è°ƒæ•´

**SAMçš„ä¼˜åŠ¿**ï¼š
1. **åˆ†ç¦»å¼æ¶æ„**ï¼šé‡é‡çº§çš„Encoderåœ¨åç«¯è·‘ï¼Œè½»é‡çº§çš„Decoderåœ¨å‰ç«¯è·‘
2. **å¿«é€Ÿæ¨ç†**ï¼šDecoderåªæœ‰4Må‚æ•°ï¼Œæµè§ˆå™¨æ¨ç†50-200ms
3. **äº¤äº’å‹å¥½**ï¼šæ”¯æŒå¢é‡è®¡ç®—ï¼ˆåˆ©ç”¨ä¸Šä¸€æ¬¡çš„ç»“æœï¼‰

---

## ç¬¬ä¹ç« ï¼šCanvaså›¾åƒå¤„ç†åŸç†

### 9.1 Canvasçš„åƒç´ æ“ä½œ

#### ImageDataçš„æ•°æ®ç»“æ„

```typescript
const imageData = ctx.getImageData(0, 0, width, height);
// imageData.data: Uint8ClampedArrayï¼Œé•¿åº¦ = width * height * 4
```

**å­˜å‚¨é¡ºåº**ï¼ˆè¡Œä¼˜å…ˆï¼‰ï¼š
```
åƒç´ (0,0): [R0, G0, B0, A0]
åƒç´ (1,0): [R1, G1, B1, A1]
åƒç´ (2,0): [R2, G2, B2, A2]
...
åƒç´ (0,1): [Rw, Gw, Bw, Aw]
```

**åæ ‡åˆ°ç´¢å¼•çš„è½¬æ¢**ï¼š
```typescript
function getPixelIndex(x, y, width) {
  return (y * width + x) * 4;
}

// è¯»å–åƒç´ 
const idx = getPixelIndex(10, 20, width);
const r = imageData.data[idx];
const g = imageData.data[idx + 1];
const b = imageData.data[idx + 2];
const a = imageData.data[idx + 3];

// å†™å…¥åƒç´ 
imageData.data[idx] = 255;      // R
imageData.data[idx + 1] = 0;    // G
imageData.data[idx + 2] = 0;    // B
imageData.data[idx + 3] = 255;  // A
```

### 9.2 æ··åˆæ¨¡å¼è¯¦è§£

#### source-overï¼ˆé»˜è®¤ï¼‰

```
alpha_out = alpha_source + alpha_dest * (1 - alpha_source)
color_out = (color_source * alpha_source + color_dest * alpha_dest * (1 - alpha_source)) / alpha_out
```

**ç¤ºä¾‹**ï¼š
```
ç›®æ ‡ï¼šRGBA(100, 100, 100, 0.5)
æºï¼š  RGBA(255, 0, 0, 0.8)

alpha_out = 0.8 + 0.5 * (1 - 0.8) = 0.9
R_out = (255*0.8 + 100*0.5*0.2) / 0.9 = 237
ç»“æœï¼šRGBA(237, 11, 11, 0.9)
```

#### destination-outï¼ˆæ“¦é™¤ï¼‰

```
alpha_out = alpha_dest * (1 - alpha_source)
color_out = color_dest
```

**ç¤ºä¾‹**ï¼š
```
ç›®æ ‡ï¼šRGBA(100, 100, 100, 0.8)
æºï¼š  RGBA(ä»»æ„, ä»»æ„, ä»»æ„, 1.0)

alpha_out = 0.8 * (1 - 1.0) = 0
ç»“æœï¼šå®Œå…¨é€æ˜
```

#### source-inï¼ˆé®ç½©ï¼‰

```
alpha_out = alpha_source * alpha_dest
color_out = color_source
```

**åº”ç”¨**ï¼šå®ç°æŠ å›¾
```typescript
// 1. ç»˜åˆ¶maskï¼ˆç™½è‰²=å‰æ™¯ï¼Œé»‘è‰²=èƒŒæ™¯ï¼‰
      ctx.drawImage(maskCanvas, 0, 0);

// 2. ä½¿ç”¨source-inæ··åˆåŸå›¾
ctx.globalCompositeOperation = 'source-in';
ctx.drawImage(originalImage, 0, 0);

// ç»“æœï¼šåªä¿ç•™maskç™½è‰²åŒºåŸŸçš„åŸå›¾å†…å®¹
```

### 9.3 åæ ‡å˜æ¢åŸç†

#### å˜æ¢çŸ©é˜µ

Canvasçš„å˜æ¢ä½¿ç”¨3Ã—3çŸ©é˜µï¼š
```
[a  c  e]   [x]   [a*x + c*y + e]
[b  d  f] Ã— [y] = [b*x + d*y + f]
[0  0  1]   [1]   [1]
```

- `a, d`ï¼šç¼©æ”¾
- `b, c`ï¼šå€¾æ–œ/æ—‹è½¬
- `e, f`ï¼šå¹³ç§»

#### æ—‹è½¬90åº¦

```typescript
ctx.rotate(-90 * Math.PI / 180);
// å¯¹åº”çŸ©é˜µï¼š
// [cos(-90)  -sin(-90)  0]   [0   1  0]
// [sin(-90)   cos(-90)  0] = [-1  0  0]
// [0          0         1]   [0   0  1]
```

å˜æ¢æ•ˆæœï¼š
```
(x, y) â†’ (y, -x)
```

#### ç¿»è½¬ + æ—‹è½¬

```typescript
ctx.scale(1, -1);     // Yè½´ç¿»è½¬
ctx.rotate(-90Â°);     // æ—‹è½¬90åº¦

// ç»„åˆçŸ©é˜µï¼š
// [1   0  0]   [0   1  0]   [0   1  0]
// [0  -1  0] Ã— [-1  0  0] = [1   0  0]
// [0   0  1]   [0   0  1]   [0   0  1]
```

å˜æ¢æ•ˆæœï¼š
```
(x, y) â†’ (y, x)
```

è¿™æ­£æ˜¯RLEè§£ç æ—¶éœ€è¦çš„åæ ‡è½¬æ¢ï¼

### 9.4 æ€§èƒ½ä¼˜åŒ–åŸç†

#### ç¦»å±Canvas

```typescript
// âŒ ç›´æ¥æ“ä½œå¯è§Canvasï¼ˆæ…¢ï¼‰
for (let i = 0; i < 100; i++) {
  visibleCtx.fillRect(...);  // æ¯æ¬¡éƒ½è§¦å‘é‡ç»˜
}

// âœ… å…ˆåœ¨ç¦»å±Canvasæ“ä½œï¼ˆå¿«ï¼‰
const offscreen = document.createElement('canvas');
const offCtx = offscreen.getContext('2d');

for (let i = 0; i < 100; i++) {
  offCtx.fillRect(...);  // ä¸è§¦å‘é‡ç»˜
}

visibleCtx.drawImage(offscreen, 0, 0);  // ä¸€æ¬¡æ€§ç»˜åˆ¶
```

#### willReadFrequentlyé€‰é¡¹

```typescript
// å¦‚æœé¢‘ç¹è¯»å–åƒç´ 
const ctx = canvas.getContext('2d', {
  willReadFrequently: true  // ä¼˜åŒ–getImageDataæ€§èƒ½
});
```

æµè§ˆå™¨ä¼šï¼š
- åœ¨CPUå†…å­˜ä¿ç•™ä¸€ä»½åƒç´ æ•°æ®å‰¯æœ¬
- é¿å…é¢‘ç¹çš„GPUâ†’CPUä¼ è¾“

#### ImageBitmap

```typescript
// æ™®é€šImageï¼ˆè§£ç æ˜¯åŒæ­¥çš„ï¼Œå¯èƒ½é˜»å¡ï¼‰
const img = new Image();
img.src = url;
img.onload = () => {
  ctx.drawImage(img, 0, 0);  // å¯èƒ½å¾ˆæ…¢
};

// ImageBitmapï¼ˆå¼‚æ­¥è§£ç ï¼‰
const blob = await fetch(url).then(r => r.blob());
const bitmap = await createImageBitmap(blob);
ctx.drawImage(bitmap, 0, 0);  // æ›´å¿«
```

---

# ç¬¬äº”éƒ¨åˆ†ï¼šå®æˆ˜è¿›é˜¶

## ç¬¬åç« ï¼šæ€§èƒ½ä¼˜åŒ–å®æˆ˜

### 10.1 åŠ è½½æ€§èƒ½ä¼˜åŒ–

#### æ¨¡å‹é¢„åŠ è½½

```typescript
class AppInitializer {
  async init() {
    // å¹¶è¡ŒåŠ è½½
    await Promise.all([
      this.preloadSamModel(),
      this.preloadCommonImages(),
      this.warmupCanvas()
    ]);
  }
  
  private async preloadSamModel() {
    const modelUrl = 'https://cdn.com/sam_decoder.onnx';
    await OnnxModelService.getModel({ onnxUrl: modelUrl });
    console.log('SAMæ¨¡å‹å·²é¢„åŠ è½½');
  }
  
  private async preloadCommonImages() {
    // é¢„åŠ è½½å¸¸ç”¨å›¾æ ‡ã€çº¹ç†ç­‰
    const urls = ['icon1.png', 'icon2.png'];
    await Promise.all(urls.map(url => this.loadImage(url)));
  }
  
  private async warmupCanvas() {
    // åˆ›å»ºä¸€ä¸ªå°Canvasï¼Œè§¦å‘æµè§ˆå™¨åˆå§‹åŒ–Canvasç¯å¢ƒ
    const canvas = document.createElement('canvas');
    canvas.width = canvas.height = 1;
    canvas.getContext('2d');
  }
}
```

#### Service Workerç¼“å­˜

```typescript
// sw.js
const CACHE_NAME = 'sam-v1';
const urlsToCache = [
  '/sam_decoder.onnx',
  '/sam_encoder_wasm.wasm'
];

self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME).then((cache) => {
      return cache.addAll(urlsToCache);
    })
  );
});

self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request).then((response) => {
      return response || fetch(event.request);
    })
  );
});
```

### 10.2 è¿è¡Œæ—¶æ€§èƒ½ä¼˜åŒ–

#### Web Workerå¸è½½è®¡ç®—

```typescript
// main.js
const worker = new Worker('sam-worker.js');

worker.postMessage({
  type: 'decode_rle',
  rle: { counts: [...], size: [1024, 768] }
});

worker.onmessage = (e) => {
  const { maskData } = e.data;
  // ä½¿ç”¨è§£ç åçš„æ•°æ®
};

// sam-worker.js
self.onmessage = (e) => {
  const { type, rle } = e.data;
  
  if (type === 'decode_rle') {
    const maskData = decodeRLE(rle);
    self.postMessage({ maskData }, [maskData.buffer]);  // è½¬ç§»æ‰€æœ‰æƒ
  }
};
```

#### å¯¹è±¡æ± æ¨¡å¼

```typescript
class CanvasPool {
  private pool: HTMLCanvasElement[] = [];
  private inUse = new Set<HTMLCanvasElement>();
  
  acquire(width: number, height: number): HTMLCanvasElement {
    let canvas = this.pool.pop();
    
    if (!canvas) {
      canvas = document.createElement('canvas');
    }
    
    canvas.width = width;
    canvas.height = height;
    this.inUse.add(canvas);
    
    return canvas;
  }
  
  release(canvas: HTMLCanvasElement) {
    if (this.inUse.has(canvas)) {
      this.inUse.delete(canvas);
      
      // æ¸…ç©ºå†…å®¹
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // é™åˆ¶æ± å¤§å°
      if (this.pool.length < 10) {
        this.pool.push(canvas);
      } else {
        canvas.width = canvas.height = 1;  // é‡Šæ”¾å†…å­˜
      }
    }
  }
}
```

### 10.3 å†…å­˜ä¼˜åŒ–

#### åŠæ—¶é‡Šæ”¾èµ„æº

```typescript
class MaskEditor {
  private currentModel: AutoMaskModel | null = null;
  
  async loadImage(url: string) {
    // é‡Šæ”¾æ—§æ¨¡å‹
    if (this.currentModel) {
      this.currentModel.release();
      this.currentModel = null;
    }
    
    // åˆ›å»ºæ–°æ¨¡å‹
    this.currentModel = await factory.createAutoMaskModel(url);
  }
  
  destroy() {
    this.currentModel?.release();
    this.currentModel = null;
  }
}
```

#### å†…å­˜æ³„æ¼æ£€æµ‹

```typescript
class MemoryMonitor {
  private baseline: number = 0;
  
  start() {
    if (performance.memory) {
      this.baseline = performance.memory.usedJSHeapSize;
    }
  }
  
  check(label: string) {
    if (performance.memory) {
      const current = performance.memory.usedJSHeapSize;
      const diff = (current - this.baseline) / 1024 / 1024;
      console.log(`${label}: ${diff.toFixed(2)}MB`);
      
      if (diff > 500) {
        console.warn('âš ï¸ å†…å­˜å¢é•¿å¼‚å¸¸ï¼');
      }
    }
  }
}

// ä½¿ç”¨
const monitor = new MemoryMonitor();
monitor.start();

await model.loadImage(url1);
monitor.check('åŠ è½½å›¾ç‰‡1');

await model.loadImage(url2);
monitor.check('åŠ è½½å›¾ç‰‡2');  // åº”è¯¥æ¥è¿‘å›¾ç‰‡1çš„å†…å­˜
```

---

## ç¬¬åä¸€ç« ï¼šå¸¸è§é—®é¢˜è§£å†³

### 11.1 åæ ‡ç³»é—®é¢˜

**é—®é¢˜**ï¼šç‚¹å‡»ä½ç½®ä¸å‡†ç¡®

**åŸå› **ï¼šå±å¹•åæ ‡ â‰  Canvasåæ ‡ â‰  åŸå›¾åæ ‡

**è§£å†³æ–¹æ¡ˆ**ï¼š
```typescript
function getImageCoordinates(
  event: MouseEvent,
  canvas: HTMLCanvasElement,
  image: HTMLImageElement
): [number, number] {
  
  // 1. è·å–Canvasè¾¹ç•Œ
  const rect = canvas.getBoundingClientRect();
  
  // 2. å±å¹•åæ ‡ â†’ Canvasåæ ‡
  const canvasX = event.clientX - rect.left;
  const canvasY = event.clientY - rect.top;
  
  // 3. Canvasåæ ‡ â†’ åŸå›¾åæ ‡
  const scaleX = image.naturalWidth / canvas.width;
  const scaleY = image.naturalHeight / canvas.height;
  
  const imageX = canvasX * scaleX;
  const imageY = canvasY * scaleY;
  
  return [imageX, imageY];
}
```

### 11.2 è·¨åŸŸé—®é¢˜

**é—®é¢˜**ï¼š`getImageData` æŠ¥é”™ "Tainted canvases may not be exported"

**åŸå› **ï¼šå›¾ç‰‡è·¨åŸŸï¼ŒCanvasè¢«æ±¡æŸ“

**è§£å†³æ–¹æ¡ˆ1**ï¼šæœåŠ¡å™¨é…ç½®CORS
```nginx
add_header Access-Control-Allow-Origin "*";
```

**è§£å†³æ–¹æ¡ˆ2**ï¼šä½¿ç”¨ä»£ç†
```typescript
function getProxiedUrl(url: string): string {
  return `/api/image-proxy?url=${encodeURIComponent(url)}`;
}

// åç«¯å®ç°
app.get('/api/image-proxy', async (req, res) => {
  const url = req.query.url;
  const response = await fetch(url);
  const buffer = await response.buffer();
  res.set('Access-Control-Allow-Origin', '*');
  res.send(buffer);
});
```

### 11.3 æµè§ˆå™¨å…¼å®¹æ€§

**æ£€æµ‹æ”¯æŒ**ï¼š
```typescript
function checkBrowserSupport(): {
  supported: boolean;
  missing: string[];
} {
  const missing: string[] = [];
  
  // æ£€æµ‹BigInt64Array
  if (typeof BigInt64Array === 'undefined') {
    missing.push('BigInt64Array');
  }
  
  // æ£€æµ‹Canvas
  const canvas = document.createElement('canvas');
  if (!canvas.getContext) {
    missing.push('Canvas');
  }
  
  // æ£€æµ‹WebAssembly
  if (typeof WebAssembly === 'undefined') {
    missing.push('WebAssembly');
  }
  
  return {
    supported: missing.length === 0,
    missing
  };
}

// ä½¿ç”¨
const { supported, missing } = checkBrowserSupport();
if (!supported) {
  alert(`æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒï¼š${missing.join(', ')}`);
}
```

---

## ç»“è¯­

### ä½ å­¦åˆ°äº†ä»€ä¹ˆï¼Ÿ

é€šè¿‡è¿™ä»½æ–‡æ¡£ï¼Œä½ åº”è¯¥æŒæ¡äº†ï¼š

**ä½¿ç”¨å±‚é¢**ï¼š
- âœ… å¦‚ä½•å¿«é€Ÿé›†æˆ@lego/sam
- âœ… å¦‚ä½•å¤„ç†ç”¨æˆ·äº¤äº’
- âœ… å¦‚ä½•å¯¼å‡ºå’Œä½¿ç”¨ç»“æœ

**æ•°æ®å±‚é¢**ï¼š
- âœ… åç«¯è¿”å›çš„æ•°æ®ç»“æ„
- âœ… æ¯ä¸ªé˜¶æ®µçš„æ•°æ®å˜æ¢
- âœ… RLEã€Embeddingã€Tensorçš„å«ä¹‰

**å®ç°å±‚é¢**ï¼š
- âœ… RLEè§£ç ç®—æ³•
- âœ… é¢œè‰²IDæ‹¾å–ç³»ç»Ÿ
- âœ… Canvaså›¾å±‚åˆæˆ
- âœ… ONNXæ¨ç†æµç¨‹

**åŸç†å±‚é¢**ï¼š
- âœ… SAMæ¨¡å‹çš„ä¸‰å±‚æ¶æ„
- âœ… Canvaså›¾åƒå¤„ç†åŸç†
- âœ… åæ ‡å˜æ¢æ•°å­¦åŸºç¡€

### ä¸‹ä¸€æ­¥å­¦ä¹ å»ºè®®

1. **åŠ¨æ‰‹å®è·µ**ï¼šåˆ›å»ºä¸€ä¸ªç®€å•çš„å›¾ç‰‡ç¼–è¾‘å™¨
2. **é˜…è¯»æºç **ï¼šæ·±å…¥ç†è§£æ¯ä¸ªç»†èŠ‚
3. **æ€§èƒ½è°ƒä¼˜**ï¼šé’ˆå¯¹å®é™…åœºæ™¯ä¼˜åŒ–
4. **æ‰©å±•åŠŸèƒ½**ï¼šæ·»åŠ æ›´å¤šç¼–è¾‘èƒ½åŠ›

### å‚è€ƒèµ„æº

- **SAMè®ºæ–‡**ï¼šhttps://arxiv.org/abs/2304.02643
- **ONNX Runtime**ï¼šhttps://onnxruntime.ai/docs/tutorials/web/
- **Canvas API**ï¼šhttps://developer.mozilla.org/en-US/docs/Web/API/Canvas_API

---

**æ–‡æ¡£ç‰ˆæœ¬**ï¼šv2.0  
**æœ€åæ›´æ–°**ï¼š2026-01-19  
**ä½œè€…**ï¼šèµ„æ·±å‰ç«¯ä¸“å®¶ & å¤§æ¨¡å‹æŠ€æœ¯è®²å¸ˆ  
**é€‚ç”¨äº**ï¼š@lego/sam v1.1.1+

